"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const models_1 = require("./models");
const utils_1 = require("./utils");
const { Form, AutoComplete } = require("enquirer");
const sequelize = models_1.default.sequelize;
const createFormArgs = (name, message, choices) => {
    let formArgs = { name, message, choices: [] };
    Object.keys(choices).forEach(key => {
        formArgs.choices.push({ name: key, message: choices[key] });
    });
    return formArgs;
};
const getRequiredFields = (model) => {
    let raw = model.rawAttributes;
    return Object.keys(raw).filter(key => {
        let entry = raw[key];
        return !entry["_autoGenerated"] && !entry.autoIncrement && !entry.references;
    });
};
const getRelatedFields = (model) => {
    let raw = model.rawAttributes;
    return Object.keys(raw).reduce((related, key) => {
        let entry = raw[key];
        let { references } = entry;
        if (references) {
            related[key] = references;
        }
        return related;
    }, {});
};
const getFieldChoices = (association) => __awaiter(void 0, void 0, void 0, function* () {
    let choices = Object.keys(association).map((fieldName) => __awaiter(void 0, void 0, void 0, function* () {
        let { model, key } = association[fieldName];
        const [result, _] = yield sequelize.query(`SELECT * FROM ${model}`);
        return [result, fieldName];
    }));
    let choice_ids = Object.keys(association).map((fieldName) => __awaiter(void 0, void 0, void 0, function* () {
        let { model, key } = association[fieldName];
        const [result, _] = yield sequelize.query(`SELECT ${key} FROM ${model}`);
        return [result, key];
    }));
    return Promise.all([...choices, ...choice_ids]);
});
const showChoices = (choiceLists, relatedFields, callback) => {
    let _choiceLists = choiceLists.slice(0, choiceLists.length / 2); // list of full records fetched from db
    let choiceIdLists = choiceLists.slice(choiceLists.length / 2); // list of records with just id fetched from db
    _choiceLists.forEach((choiceTuple, idx) => {
        let [choiceList, fieldName] = choiceTuple;
        let choiceStrings = [];
        let choices = choiceList.map(choice => {
            // just concat each record object into big searchable strings
            let choiceStr = Object.keys(choice).map(key => choice[key]).join(", ");
            choiceStrings.push(choiceStr);
        });
        let message = `Make a selection for related field ${fieldName}.`;
        const prompt = new AutoComplete({ name: fieldName, message, choices: [...choiceStrings] });
        prompt.run().then((answer) => {
            let [choiceIds, keyName] = choiceIdLists[idx];
            callback([fieldName, choiceIds[choiceStrings.indexOf(answer)][keyName]], idx === _choiceLists.length - 1);
        }).catch(console.error);
    });
};
const relatedFieldsPrompt = (relatedFields, createCallback) => {
    // const relatedFields = getRelatedFields(model)
    const fieldChoicePromises = getFieldChoices(relatedFields);
    let populatedFields = {};
    const callback = (value_tuple, isLast) => {
        let [key, value] = value_tuple;
        populatedFields[key] = value;
        if (isLast) {
            createCallback(populatedFields);
        }
    };
    fieldChoicePromises.then((choices) => {
        showChoices(choices, relatedFields, callback);
    }).catch(console.error);
};
exports.userDataPrompt = (model) => {
    const fields = getRequiredFields(model).reduce((fields, field) => {
        return Object.assign(Object.assign({}, fields), { [field]: field });
    }, {});
    let formArgs = createFormArgs(`Create a ${model}`, "Fill out the fields for your new ${model} below.", fields);
    const prompt = new Form(formArgs);
    prompt.run()
        .then((answer) => {
        const create = (extras) => {
            const user = model.create(Object.assign(Object.assign({}, answer), extras)).catch(console.error);
        };
        const relatedFields = getRelatedFields(model);
        if (utils_1.isEmpty(relatedFields)) {
            create({});
        }
        else {
            relatedFieldsPrompt(relatedFields, create);
        }
    })
        .catch(console.error);
};
exports.selectModel = (selection) => {
    let modelNames = Object.keys(models_1.default);
    for (let i in modelNames) {
        if (modelNames[i].toUpperCase() === selection.toUpperCase()) {
            return models_1.default[modelNames[i]];
        }
    }
    return null;
};
//# sourceMappingURL=dataPrompts.js.map