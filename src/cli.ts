import { User, Project, sequelize } from './models'
import { Model } from "sequelize"
import { create } from 'domain';

const { Form, AutoComplete } = require("enquirer");
const { forceSync } = require('sync-rpc');

type PromptAnswer = {
  result: string
}

// type necessary to allow
// passing of aribitrary model classes to
// function
type ModelType = typeof Model & {
  create(object: object): Promise<object>,
}

const createFormArgs = (name: string, message: string, choices: object) => {
  let formArgs = { name, message, choices: [] }
  let templateFields = []
  Object.keys(choices).forEach(key => {
    formArgs.choices.push({name: key, message: choices[key]})
  })
  return formArgs
}

const getRequiredFields = (model: ModelType) => {
  let raw = model.rawAttributes
  return Object.keys(raw).filter(key => {
    let entry = raw[key]
    return !entry["_autoGenerated"] && !entry.autoIncrement && !entry.references
  })
}

const getRelatedFields = (model: ModelType) => {
  let raw = model.rawAttributes
  return Object.keys(raw).reduce((related, key) => {
    let entry = raw[key]
    let { references } = entry
    if (references) {
      related[key] = references
    }
    return related
  }, {})
}

const getFieldChoices = async (association: object) => {
  let names: string[] = []
  let choices = Object.keys(association).map(async fieldName => {
    names.push(fieldName)
    let { model, key } = association[fieldName]
    return await sequelize.query(`SELECT * FROM ${model}`)
  })
  let choice_ids = Object.keys(association).map(async fieldName => {
    names.push(fieldName)
    let { model, key } = association[fieldName]
    return await sequelize.query(`SELECT ${key} FROM ${model}`)
  })
  return Promise.all([...choices, ...choice_ids])
}

const showChoices = (choices, callback) => {
  let _choices = choices.slice(0, choices.length/2)
  let choiceIds = choices.slice(choices.length/2)
  _choices.forEach(_choice => {
    let [ choice, _ ] = _choice;
    const prompt = new AutoComplete({name:"ok", message: "ok", choices: choice})
    prompt.run().then(callback).catch(console.error)
  })
}

const performPrompt = (model: ModelType) => {
  const fields = getRequiredFields(model).reduce((fields, field) => {
    return {...fields, [field]: field}
  }, {})
  let formArgs = createFormArgs(`Create a ${model}`, "Fill out the fields for your new ${model} below.", fields)
  const prompt = new Form(formArgs)
  prompt.run()
  .then((answer: object) => {
    const user = model.create(answer);
    user.catch(console.error)
  })
  .catch(console.error);
}

const related = (model: ModelType) => {
  const relatedFields = getRelatedFields(model)
  const fieldChoicePromises = getFieldChoices(relatedFields)
  fieldChoicePromises.then((choices) => showChoices(choices, console.log)).catch(console.error)
}

// performPrompt(User)
// performPrompt(Project)

// console.log(getRelatedFields(Project))
// getFieldChoices({ ownerId: { model: 'users', key: 'id' } }).then(console.log).catch(console.error)
// getFieldChoices({ ownerId: { model: 'users', key: 'id' } }).catch(console.error)
// console.log(getFieldChoices({ ownerId: { model: 'users', key: 'id' } }))
// console.log("dang")

related(Project)