import { User, Project, sequelize } from './models'
import { Model } from "sequelize"
import { create } from 'domain';

const { Form, AutoComplete } = require("enquirer");

type PromptAnswer = {
  result: string
}

// type necessary to allow
// passing of aribitrary model classes to
// function
type ModelType = typeof Model & {
  create(object: object): Promise<object>,
}

const createFormArgs = (name: string, message: string, choices: object) => {
  let formArgs = { name, message, choices: [] }
  let templateFields = []
  Object.keys(choices).forEach(key => {
    formArgs.choices.push({name: key, message: choices[key]})
  })
  return formArgs
}

const getRequiredFields = (model: ModelType) => {
  let raw = model.rawAttributes
  return Object.keys(raw).filter(key => {
    let entry = raw[key]
    return !entry["_autoGenerated"] && !entry.autoIncrement && !entry.references
  })
}

const getRelatedFields = (model: ModelType) => {
  let raw = model.rawAttributes
  return Object.keys(raw).reduce((related, key) => {
    let entry = raw[key]
    let { references } = entry
    if (references) {
      related[key] = references
    }
    return related
  }, {})
}

const getFieldChoices = async (association: object) => {
  let choices = Object.keys(association).map(async fieldName => {
    let { model, key } = association[fieldName]
    const [result, _ ] = await sequelize.query(`SELECT * FROM ${model}`)
    return [result, fieldName]
  })
  let choice_ids = Object.keys(association).map(async fieldName => {
    let { model, key } = association[fieldName]
    const [result, _ ] = await sequelize.query(`SELECT ${key} FROM ${model}`)
    return [result, key]
  })
  return Promise.all([...choices, ...choice_ids])
}

const showChoices = (choiceLists, relatedFields, callback) => {
  let _choiceLists = choiceLists.slice(0, choiceLists.length/2) // list of full records fetched from db
  let choiceIdLists = choiceLists.slice(choiceLists.length/2) // list of records with just id fetched from db
  _choiceLists.forEach((choiceTuple, idx) => {
    let [choiceList, fieldName] = choiceTuple
    let choiceStrings = [];
    let choices = choiceList.map(choice => {
      // just concat each record object into big searchable strings
      let choiceStr = Object.keys(choice).map(key => choice[key]).join(", ")
      choiceStrings.push(choiceStr)
    })
    let message = `Make a selection for related field ${fieldName}.`
    const prompt = new AutoComplete({name: fieldName, message, choices: [...choiceStrings]})
    prompt.run().then((answer: string)=> {
      let [choiceIds, keyName] = choiceIdLists[idx]
      callback(choiceIds[choiceStrings.indexOf(answer)][keyName], idx === _choiceLists.length - 1)
    }).catch(console.error)
  })
}

const performPrompt = (model: ModelType) => {
  const fields = getRequiredFields(model).reduce((fields, field) => {
    return {...fields, [field]: field}
  }, {})
  let formArgs = createFormArgs(`Create a ${model}`, "Fill out the fields for your new ${model} below.", fields)
  const prompt = new Form(formArgs)
  prompt.run()
  .then((answer: object) => {
    const user = model.create(answer);
    user.catch(console.error)
  })
  .catch(console.error);
}

const related = (model: ModelType) => {
  const relatedFields = getRelatedFields(model)
  const fieldChoicePromises = getFieldChoices(relatedFields)
  let ids = [];
  const callback = (id, isLast) => {
    ids.push(id);
    if (isLast) {
      console.log(ids)
    }
  }
  fieldChoicePromises.then((choices) => {
    showChoices(choices, relatedFields, console.log)
  }).catch(console.error)
}

related(Project)