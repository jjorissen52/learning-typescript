import models from './models'
import { isEmpty } from "./utils"
//@ts-ignore
import { Model } from "sequelize"

const { Form, AutoComplete } = require("enquirer");

const sequelize = models.sequelize

type PromptAnswer = {
  result: string
}

// type necessary to allow
// passing of aribitrary model classes to
// function
export type ModelType = typeof Model & {
  create(object: object): Promise<object>,
}

const createFormArgs = (name: string, message: string, choices: object) => {
  let formArgs = { name, message, choices: [] }
  Object.keys(choices).forEach(key => {
    formArgs.choices.push({name: key, message: choices[key]})
  })
  return formArgs
}

const getRequiredFields = (model: ModelType): string[] => {
  let raw = model.rawAttributes
  return Object.keys(raw).filter(key => {
    let entry = raw[key]
    return !entry["_autoGenerated"] && !entry.autoIncrement && !entry.references
  })
}

const getRelatedFields = (model: ModelType) => {
  let raw = model.rawAttributes
  return Object.keys(raw).reduce((related, key) => {
    let entry = raw[key]
    let { references } = entry
    if (references) {
      related[key] = references
    }
    return related
  }, {})
}

const getFieldChoices = async (association: object) => {
  let choices = Object.keys(association).map(async fieldName => {
    let { model, key } = association[fieldName]
    const [result, _ ] = await sequelize.query(`SELECT * FROM ${model}`)
    return [result, fieldName]
  })
  let choice_ids = Object.keys(association).map(async fieldName => {
    let { model, key } = association[fieldName]
    const [result, _ ] = await sequelize.query(`SELECT ${key} FROM ${model}`)
    return [result, key]
  })
  return Promise.all([...choices, ...choice_ids])
}

const showChoices = (choiceLists, relatedFields, callback) => {
  let _choiceLists = choiceLists.slice(0, choiceLists.length/2) // list of full records fetched from db
  let choiceIdLists = choiceLists.slice(choiceLists.length/2) // list of records with just id fetched from db
  _choiceLists.forEach((choiceTuple, idx) => {
    let [choiceList, fieldName] = choiceTuple
    let choiceStrings = [];
    let choices = choiceList.map(choice => {
      // just concat each record object into big searchable strings
      let choiceStr = Object.keys(choice).map(key => choice[key]).join(", ")
      choiceStrings.push(choiceStr)
    })
    let message = `Make a selection for related field ${fieldName}.`
    const prompt = new AutoComplete({name: fieldName, message, choices: [...choiceStrings]})
    prompt.run().then((answer: string)=> {
      let [choiceIds, keyName] = choiceIdLists[idx]
      callback([fieldName, choiceIds[choiceStrings.indexOf(answer)][keyName]], idx === _choiceLists.length - 1)
    }).catch(console.error)
  })
}

const relatedFieldsPrompt = (relatedFields: object, createCallback: Function) => {
  // const relatedFields = getRelatedFields(model)
  const fieldChoicePromises = getFieldChoices(relatedFields)
  let populatedFields = {}
  const callback = (value_tuple: [string, BigInteger], isLast: boolean) => {
    let [key, value] = value_tuple;
    populatedFields[key] = value;
    if (isLast) {
      createCallback(populatedFields)
    }
  }
  fieldChoicePromises.then((choices) => {
    showChoices(choices, relatedFields, callback)
  }).catch(console.error)
}

export const userDataPrompt = (model: ModelType) => {
  const fields = getRequiredFields(model).reduce((fields, field) => {
    return {...fields, [field]: field}
  }, {})
  let formArgs = createFormArgs(`Create a ${model}`, "Fill out the fields for your new ${model} below.", fields)
  const prompt = new Form(formArgs)
  prompt.run()
  .then((answer: object) => {
    const create = (extras: object) => {
      const user = model.create({...answer, ...extras}).catch(console.error);
    }
    const relatedFields = getRelatedFields(model)
    if (isEmpty(relatedFields)) {
      create({})
    } else {
      relatedFieldsPrompt(relatedFields, create)
    }
  })
  .catch(console.error);
}

export const selectModel = (selection: string): ModelType|null => {
  let modelNames = Object.keys(models);
  for (let i in modelNames){
    if (modelNames[i].toUpperCase() === selection.toUpperCase()) {
      return models[modelNames[i]]
    }
  }
  return null
}